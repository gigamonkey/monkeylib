-*- mode: smart-text; -*-

* Purpose 

This library provides a way to use the various FOO languages from templates contained in external (i.e. non-Lisp source) files. The basic idea is that in a bit of lisp code you can achieve the equivalent effect to inlining a bit of some FOO language except with more dynamism. There are a couple levels of dynamism we want to support. First, it should be possible to write code that “invokes” a template file that is not known until runtime. This allows us to write code that will generate different output depending on runtime choice of what template to use. For instance, the \code{com.gigamonkeys.blog} library allows the blogger to provide two FOO/HTML templates that define the basic look and feel of their blog. Additionally we want changes to the template files to be reflected immediately in the output. To implement these levels of dynamism moderately efficiently, we use a multilevel caching strategy.

* Caching strategy

In principle a call to the \code{TEMPLATE} macro could simply expand into code that reads the template and expands it every time the code runs. However it seems a bit unfortunate to go through all the work every time. Instead we can keep track of when we generate the template expansion function and save the function. If neither the template file nor any of files it statically interpolates have changed since the function was last generated and compiled, we can reuse the existing function.

Another level of caching is to save the output of running the template function to a file and then simply dump out the file if nothing has changed that could change the output. Unfortunately knowing whether the template output could change dynamically is harder to determine auttomatically. Some templates will contain code that generates different output every time it runs. Others may be completely static. In the middle there are templates that generate different output depending on some data external to the template. 
Only the author of the template will know which kind a given template is. The other piece of information the author of the \code{TEMPLATE} call must supply is the name of the file in which to store the cached output — the same call site can generate different output depending on things other than the template and, in theory though less likely in practice, different call sites could generate the same output and would thus like to share a cache file. So if a given use of \code{TEMPLATE} is going to do output caching the caller needs to provide two forms: one that will evaluate (in the lexical context of the call site) to the name of the cache file and another which will evaluate to the time the dynamic inputs to the template were last changed.


In order to know whether the contents have changed the caller of \code{TEMPLATE} have to provide a form that will evaluate to a timestamp representing the most recent time any dynamic elements contributing to the output have changed. For instance a template that generates it’s output based on a data file might provide \code{(file-write-date data-file)}. The default is \cl{T} which means the contents are always newer than the cache and therefore not to cache output at all. 



In the case of a completely static template we want to cache the output but \i{not} the expansion function. When we are caching the output we need the name of a file in which to store it. Unfortunately it doesn’t seeem that we can generate the file name automatically — the same call site can generate different output depending on things other than the template and, in theory though less likely in practice, different call sites could generate the same output and would thus like to share a cache file. So if a given use of \code{TEMPLATE} is going to do output caching the caller needs to provide a form that will evaluate to the name of the cache file.

    (template () xhtml "article.fhtml"
      :cache-file (make-article-file-name article-contents))
      :contents-last-updated (file-write-date article-contents)


* Template variables

\code{TEMPLATE} is a macro rather than a function so that we can make lexical variables available to the template. 

    (defun foo (x y z)
      (template (x y z) xhtml "foo.fhtml"))


    (template (x y z) xhtml "template.fhtml")

    ((lambda (x y z) (xhtml <contents of template file>)) x y z)

    (template ((x (random-number))) xhtml "foo.fhtml")

    ((lambda (x) (xhtml <contents of template file>)) (random-number))


    







* Package issues

Templates are read at runtime but will often need to refer to symbols in the package or packages used by the larger application. Thus in the code we generate to expand the template we bind *PACKAGE* to its macro-expansion-time value. (Unfortunately this means that compiled and uncompiled code that uses the TEMPLATE macro will not always behave the same. If you compile a function that uses TEMPLATE then the value of *PACKAGE* will be set at compile time. If you only evaluate the function definition, without compiling, then TEMPLATE is expanded each time the function is called and *PACKAGE* will have whatever dynamic value it has.)


